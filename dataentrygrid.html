<html>
<head>
<title>Home-made grid test</title>
<meta charset='UTF-8'/>
<style>
table.data-entry-grid {
    border: 1px solid black;
    background-color: white;
    border-collapse: collapse;
    padding-left: 5px;
    padding-right: 5px;
    padding-top: 0px;
    padding-bottom: 0px;
}
table.data-entry-grid th, table.data-entry-grid td {
    border: 1px solid black;
    background-color: white;
    border-collapse: collapse;
    padding-left: 5px;
    padding-right: 5px;
    padding-top: 0px;
    padding-bottom: 0px;
}
table.data-entry-grid input {
    border: 0;
}
table.data-entry-grid td.selected {
    border: 1px solid blue;
    background-color: lightskyblue;
    border-collapse: collapse;
    padding-left: 5px;
    padding-right: 5px;
    padding-top: 0px;
    padding-bottom: 0px;
}
table.data-entry-grid td.anchor {
    border: 3px solid blue;
    background-color: lightskyblue;
    border-collapse: collapse;
    padding-left: 5px;
    padding-right: 5px;
    padding-top: 0px;
    padding-bottom: 0px;
}
</style>
<script>
function createDataEntryGrid(containerId, rows, columns) {
    var rowCount = rows;
    var columnCount = columns;
    var anchorRow = 1;
    var anchorColumn = 0;
    var selectionRow = 1;
    var selectionColumn = 0;
    var returnColumn = 0;
    var undoStack = [];
    var redoStack = [];
    var oldCellValue = '';
    var table = document.getElementById(containerId); // while we aren't creating our own table
    function undoable(action) {
        undoStack.push(action);
        redoStack = [];
    }
    function getRow(r) {
        return table.getElementsByTagName('TR')[r];
    }
    function getCell(r,c) {
        return getRow(r).getElementsByTagName('TD')[c];
    }
    function getAnchor() {
        return getCell(anchorRow, anchorColumn);
    }
    function removeContextMenu() {
        const selects = table.getElementsByTagName('SELECT');
        for (var i = selects.length - 1; i >= 0; --i) {
            select = selects[i];
            const parent = select.parentNode;
            if (parent) {
                parent.removeChild(select);
            }
        }
    }
    function getMouseCoordinates(ev) {
        // polyfill
        if (ev.pageX || ev.pageY) {
            return { x: ev.pageX, y: ev.pageY };
        }
        return {
            x: ev.clientX + document.body.scrollLeft + document.documentElement.scrollLeft,
            y: ev.clientY + document.body.scrollTop + document.documentElement.scrollTop
        }
    }
    function preventDefault(ev) {
        // Firefox polyfill
        if (ev.preventDefault) {
            ev.preventDefault();
        }
        // Standard?
        ev.canceBubble = true;
        // IE7/8 polyfill
        return false;
    }
    function getEvent(ev) {
        // polyfill
        return ev? ev : window.event;
    }
    function handleInputKey(ev) {
        ev = getEvent(ev);
        if (ev.keyCode === 9) {
            if (ev.shiftKey) {
                goToPreviousCell();
            } else {
                goToNextCell();
            }
            return preventDefault(ev);
        } else if (ev.keyCode === 13) {
            goToNextRow();
            return preventDefault(ev);
        }
        return true;
    }
    function beginEdit() {
        const input = document.createElement('INPUT');
        let maxLength = 3;
        forEachRow(1, rowCount, function(row) {
            forEachColumn(row, anchorColumn, anchorColumn+1, function(cell) {
                const c = cell.textContent.length;
                if (maxLength < c) {
                    maxLength = c;
                }
            });
        });
        input.setAttribute('size', maxLength - 2);
        const anchor = getAnchor();
        oldCellValue = input.value = anchor.textContent;
        anchor.textContent = '';
        anchor.appendChild(input);
        input.onkeydown = handleInputKey;
        input.onblur = handleInputBlur;
        input.setSelectionRange(0, input.value.length);
        input.focus();
        console.log('focus input');
    }
    function commitEdit() {
        const anchor = getAnchor();
        const inputs = anchor.getElementsByTagName('INPUT');
        if (0 < inputs.length) {
            const input = inputs[0];
            // setting textContent deletes the INPUT element
            anchor.textContent = input.value;
            if (oldCellValue !== input.value) {
                // make an undo action if we actually changed anything
                const vss = [[oldCellValue]];
                const thisRow = anchorRow;
                const thisColumn = anchorColumn;
                undoable(function() { return putCellsAction(thisRow, thisColumn, vss); });
            }
        }
    }
    function handleInputBlur() {
        commitEdit();
        table.focus();
    }
    function getTbody() {
        const tbodies = table.getElementsByTagName('TBODY');
        if (tbodies.length < 1) {
            throw 'No tbodies in table!';
        }
        return tbodies[0];
    }
    function insertRows(r, count) {
        commitEdit();
        const tbody = getTbody();
        const insertFunction = r < rowCount?
            function(child) { tbody.insertBefore(child, getRow(r)); }
            : function(child) { tbody.appendChild(child); };
        for (var i = 0; i !== count; ++i) {
            const row = document.createElement('TR');
            const rowHeader = document.createElement('TH');
            rowHeader.textContent = r + i;
            row.appendChild(rowHeader);
            for (var j = 0; j != columnCount; ++j) {
                row.appendChild(document.createElement('TD'));
            }
            insertFunction(row);
        }
        rowCount += count;
        if (r <= anchorRow) {
            anchorRow += count;
        }
        if (r <= selectionRow) {
            selectionRow += count;
        }
        setCellMouseHandlers(r);
        return function() {
            return deleteRows(r, count);
        };
    }
    function deleteRows(r, count) {
        commitEdit();
        const values = getCells(r, r+count, 0, columnCount);
        const tbody = getTbody();
        for (i = 0; i !== count; ++i) {
            tbody.removeChild(tbody.children[r - 1]);
        }
        rowCount -= count;
        if (r < anchorRow) {
            if (r + count < anchorRow) {
                anchorRow -= count;
            } else {
                anchorRow = r;
            }
        }
        if (rowCount <= anchorRow) {
            anchorRow = rowCount - 1;
        }
        if (r < selectionRow) {
            if (r + count < selectionRow) {
                selectionRow -= count;
            } else {
                selectionRow = r;
            }
        }
        if (rowCount <= selectionRow) {
            selectionRow = rowCount - 1;
        }
        setCellMouseHandlers(r);
        return function() {
            const inverse = insertRows(r, count);
            putCells(r, r+count, 0, columnCount, values);
            return inverse;
        };
    }
    function setSelection(aRow, aColumn, sRow, sColumn) {
        getAnchor().classList.remove('anchor');
        forEachSelectedRow(function(row, ii, i) {
            forEachSelectedColumn(row, function(cell, jj, j) {
                cell.classList.remove('selected');
            });
        });
        anchorRow = aRow;
        anchorColumn = aColumn;
        selectionRow = sRow;
        selectionColumn = sColumn;
        forEachSelectedRow(function(row, ii, i) {
            forEachSelectedColumn(row, function(cell, jj, j) {
                cell.classList.add('selected');
            });
        });
        getAnchor().classList.add('anchor');
    }
    function doGoToCell(r,c) {
        commitEdit();
        getAnchor().classList.remove('anchor');
        if (r < 0 || rowCount <= r
                || c < 0 || columnCount <= c) {
            return;
        }
        setSelection(r, c, r, c);
        getAnchor().classList.add('anchor');
        beginEdit();
    }
    function goToNextRow() {
        if (rowCount <= anchorRow + 1) {
            undoable(insertRows(rowCount, 1));
        }
        doGoToCell(anchorRow + 1, returnColumn);
    }
    function goToPreviousCell() {
        doGoToCell(anchorRow, anchorColumn - 1);
    }
    function goToNextCell() {
        if (anchorColumn + 1 < columnCount) {
            doGoToCell(anchorRow, anchorColumn + 1);
        } else {
            goToNextRow();
        }
    }
    function goToCell(r,c) {
        returnColumn = c;
        doGoToCell(r,c);
    }
    function deleteRowsOption(count) {
        const el = document.createElement('OPTION');
        el.setAttribute('option', 'delete');
        el.textContent = 'Delete Row';
        return el;
    }
    function addRowsBeforeOption(count) {
        const el = document.createElement('OPTION');
        el.setAttribute('option', 'add-before');
        el.textContent = 'Add Row Before';
        return el;
    }
    function addRowsAfterOption(count) {
        const el = document.createElement('OPTION');
        el.setAttribute('option', 'add-after');
        el.textContent = 'Add Row After';
        return el;
    }
    function rowHeaderMenu(ev, r) {
        let firstRow = r;
        if ((r < anchorRow && r < selectionRow)
                || anchorRow < r && selectionRow < r) {
            setSelection(r, 0, r, columnCount - 1);
        }
        const select = document.createElement('SELECT');
        select.setAttribute('size', 3);
        const deleteOption = deleteRowsOption();
        deleteOption.onclick = function() {
            undoable(deleteRows(firstRow, 1));
            removeContextMenu();
            table.focus();
        }
        select.appendChild(deleteOption);
        const addBeforeOption = addRowsBeforeOption();
        addBeforeOption.onclick = function() {
            undoable(insertRows(firstRow, 1));
            removeContextMenu();
            table.focus();
        }
        select.appendChild(addBeforeOption);
        const addAfterOption = addRowsAfterOption();
        addAfterOption.onclick = function() {
            undoable(insertRows(firstRow + 1, 1));
            removeContextMenu();
            table.focus();
        }
        select.appendChild(addAfterOption);
        const mousePosition = getMouseCoordinates(ev);
        select.style.position = 'fixed';
        select.style.left = mousePosition.x + 'px';
        select.style.top = mousePosition.y + 'px';
        select.tabIndex = -1;
        select.onblur = removeContextMenu;
        table.appendChild(select);
        return select;
    }
    function forEachRow(rowStart, rowEnd, callback) {
        const rows = table.getElementsByTagName('TR');
        const rEnd = (rows.length < rowEnd? rows.length : rowEnd) - rowStart;
        for (var i = 0; i !== rEnd; ++i) {
            callback(rows[rowStart + i], i, rowStart + i);
        }
    }
    function forEachColumn(row, columnStart, columnEnd, callback) {
        const cs = row.getElementsByTagName('TD');
        let cEnd = (row.length < columnEnd? row.length : columnEnd) - columnStart;
        for (var i = 0; i !== cEnd; ++i)  {
            callback(cs[columnStart + i], i, columnStart + i);
        }
    }
    function forEachSelectedRow(callback) {
        forEachRow(Math.min(anchorRow, selectionRow),
                Math.max(anchorRow, selectionRow) + 1, callback);
    }
    function forEachSelectedColumn(row, callback) {
        forEachColumn(row, Math.min(anchorColumn, selectionColumn),
                Math.max(anchorColumn, selectionColumn) + 1, callback);
    }
    function setCellMouseHandlers(firstRow) {
        forEachRow(firstRow, rowCount, function(row, i, thisRow) {
            rowHeaders = row.getElementsByTagName('TH');
            if (0 < rowHeaders.length) {
                const rh = rowHeaders[0];
                rh.textContent = thisRow;
                rh.oncontextmenu = function(ev) {
                    ev = getEvent(ev);
                    const select = rowHeaderMenu(ev, thisRow);
                    select.focus();
                    return preventDefault(ev);
                }
                forEachColumn(row, 0, columnCount, function(cell, j, thisColumn) {
                    cell.onclick = function() {
                        goToCell(thisRow, thisColumn);
                    };
                    cell.onmouseenter = function(ev) {
                        ev = getEvent(ev);
                        // stretch selection over this cell
                        if (ev.buttons & 1) {
                            setSelection(anchorRow, anchorColumn, thisRow, thisColumn);
                            table.focus();
                            return preventDefault(ev);
                        }
                    };
                    cell.onmousedown = function(ev) {
                        ev = getEvent(ev);
                        // set anchor and selection to this cell
                        if (ev.button === 0) {
                            commitEdit();
                            setSelection(thisRow, thisColumn, thisRow, thisColumn);
                            table.focus();
                            return preventDefault(ev);
                        }
                    }
                });
            }
        });
    }
    function getCells(rowStart, rowEnd, columnStart, columnEnd) {
        let vss = [];
        forEachRow(rowStart, rowEnd, function(row) {
            let vs = [];
            forEachColumn(row, columnStart, columnEnd, function(cell) {
                vs.push(cell.textContent);
            });
            vss.push(vs);
        });
        return vss;
    }
    function putCells(rowStart, rowEnd, columnStart, columnEnd, values) {
        forEachRow(rowStart, rowEnd, function(row, i) {
            forEachColumn(row, columnStart, columnEnd, function(cell, j) {
                cell.textContent = values[i][j];
            });
        });
    }
    function putCellsAction(rowStart, columnStart, values) {
        const rowEnd = rowStart + values.length;
        let columnCount = 0;
        values.forEach(v => {
            if (columnCount < v.length) {
                columnCount = v.length;
            }
        });
        const columnEnd = columnStart + columnCount;
        const oldValues = getCells(rowStart, rowEnd, columnStart, columnEnd);
        putCells(rowStart, rowEnd, columnStart, columnEnd, values);
        return function() { return putCellsAction(rowStart, columnStart, oldValues) };
    }
    function redo() {
        commitEdit();
        if (0 < redoStack.length) {
            const action = redoStack.pop();
            undoStack.push(action());
        }
    }
    function undo() {
        commitEdit();
        if (0 < undoStack.length) {
            const action = undoStack.pop();
            redoStack.push(action());
        }
    }
    function clearSelection() {
        let empties = [['']];
        undoable(putCellsAction(anchorRow, anchorColumn, empties));
    }
    function getClipboard() {
        const buffer = table.getElementsByClassName('data-entry-grid-copy-paste-buffer')[0];
        buffer.select();
        buffer.setSelectionRange(0, buffer.value.length);
        document.execCommand('paste');
        return buffer.value;
    }
    function putClipboard(text) {
        const buffer = table.getElementsByClassName('data-entry-grid-copy-paste-buffer')[0];
        buffer.value = text;
        console.log('copying', text);
        buffer.select();
        buffer.setSelectionRange(0, buffer.value.length);
        document.execCommand('copy');
    }
    function copySelection() {
        let texts = [];
        forEachSelectedRow(function(row) {
            let rowTexts = [];
            forEachSelectedColumn(row, function(cell) {
                rowTexts.push(cell.textContent);
            });
            texts.push(rowTexts.join('\t'));
        });
        putClipboard(texts.join('\n'));
    }
    function paste() {
        const clip = getClipboard();
        console.log('pasting', clip.length, clip);
        if (clip.length > 0) {
            let values = [];
            const lines = clip.split('\n');
            for (let i = 0; i !== lines.length; ++i) {
                values.push(lines[i].split('\t'));
            }
            undoable(putCellsAction(anchorRow, anchorColumn, values));
        }
    }
    function tableKeyDownHandler(ev) {
        ev = getEvent(ev);
        if (ev.ctrlKey || ev.metaKey) {
            if (ev.keyCode === 88) {
                copySelection();
                clearSelection();
            } else if (ev.keyCode === 67) {
                copySelection();
            } else if (ev.keyCode === 86) {
                paste();
            } else if (ev.keyCode === 90) {
                if (ev.shiftKey) {
                    redo();
                } else {
                    undo();
                }
            } else {
                return;
            }
            return preventDefault(ev);
        }
    }
    setCellMouseHandlers(1);
    table.onkeydown = tableKeyDownHandler;
    table.onmousemove = function (ev) {
        ev = getEvent(ev);
        // prevent default drag-select
        if (ev.buttons & 1) {
            return preventDefault(ev);
        }
    };
    table.onmousedown = function (ev) {
        ev = getEvent(ev);
        // prevent default drag-select
        if (ev.button === 0) {
            return preventDefault(ev);
        }
    };
    table.tabIndex = -1;
    const copyPasteBuffer = document.createElement('TEXTAREA');
    copyPasteBuffer.classList.add('data-entry-grid-copy-paste-buffer');
    copyPasteBuffer.style.position = 'fixed';
    copyPasteBuffer.style.top = '0';
    copyPasteBuffer.style.right = '100%';
    copyPasteBuffer.style.zIndex = '-1';
    copyPasteBuffer.style.opacity = '0';
    table.appendChild(copyPasteBuffer);
    return {
        goToCell: goToCell,
        undo: undo,
        redo: redo
    };
};
var dataEntryGrid;
</script>
</head>
<body onload="dataEntryGrid = createDataEntryGrid('input',3,3)">
    <table id='input' class='data-entry-grid'>
        <thead>
            <tr>
                <th></th>
                <th>One</th>
                <th>Two</th>
                <th>Three</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <th>1</th>
                <td class='anchor'>1</td>
                <td>2</td>
                <td>3</td>
            </tr>
            <tr>
                <th>2</th>
                <td>10.1</td>
                <td>20.2</td>
                <td>30.3</td>
            </tr>
        </tbody>
    </table>
</body>
</html>
