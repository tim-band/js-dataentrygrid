<html>
<head>
<title>Home-made grid test</title>
<meta charset='UTF-8'/>
<style>
table.data-entry-grid {
    border: 1px solid black;
    background-color: white;
    border-collapse: collapse;
    padding-left: 5px;
    padding-right: 5px;
    padding-top: 0px;
    padding-bottom: 0px;
}
table.data-entry-grid th, table.data-entry-grid td {
    border: 1px solid black;
    background-color: white;
    border-collapse: collapse;
    padding-left: 5px;
    padding-right: 5px;
    padding-top: 0px;
    padding-bottom: 0px;
}
table.data-entry-grid input {
    border: 0;
}
table.data-entry-grid td.selected {
    border: 1px solid blue;
    background-color: lightskyblue;
    border-collapse: collapse;
    padding-left: 5px;
    padding-right: 5px;
    padding-top: 0px;
    padding-bottom: 0px;
}
table.data-entry-grid td.anchor {
    border: 3px solid blue;
    background-color: lightskyblue;
    border-collapse: collapse;
    padding-left: 5px;
    padding-right: 5px;
    padding-top: 0px;
    padding-bottom: 0px;
}
</style>
<script>
function createDataEntryGrid(containerId, rows, columns) {
    var rowCount = rows;
    var columnCount = columns;
    var anchorRow = 1;
    var anchorColumn = 0;
    var selectionRow = 1;
    var selectionColumn = 0;
    var returnColumn = 0;
    var undoStack = [];
    var redoStack = [];
    var oldCellValue = '';
    var inputBox = null;
    var contextMenu = null;
    var table = document.getElementById(containerId); // while we aren't creating our own table
    function undoable(action) {
        undoStack.push(action);
        redoStack = [];
    }
    function getRow(r) {
        return table.getElementsByTagName('TR')[r];
    }
    function getCell(r,c) {
        return getRow(r).getElementsByTagName('TD')[c];
    }
    function getAnchor() {
        return getCell(anchorRow, anchorColumn);
    }
    function removeContextMenu() {
        if (contextMenu) {
            table.removeChild(contextMenu);
            contextMenu = null;
        }
    }
    function getMouseCoordinates(ev) {
        // polyfill
        if (ev.pageX || ev.pageY) {
            return { x: ev.pageX, y: ev.pageY };
        }
        return {
            x: ev.clientX + document.body.scrollLeft + document.documentElement.scrollLeft,
            y: ev.clientY + document.body.scrollTop + document.documentElement.scrollTop
        }
    }
    function preventDefault(ev) {
        // Firefox polyfill
        if (ev.preventDefault) {
            ev.preventDefault();
        }
        // standard?
        if (ev.stopPropagation) {
            ev.stopPropagation();
        }
        // IE polyfill
        ev.cancelBubble = true;
        // IE7/8 polyfill
        return false;
    }
    function getEvent(ev) {
        // polyfill
        return ev? ev : window.event;
    }
    function handleInputKey(ev) {
        ev = getEvent(ev);
        if (ev.keyCode === 9) {
            if (ev.shiftKey) {
                goToPreviousCell();
            } else {
                goToNextCell();
            }
            return preventDefault(ev);
        } else if (ev.keyCode === 13) {
            goToNextRow();
            return preventDefault(ev);
        }
        return true;
    }
    function beginEdit() {
        inputBox = document.createElement('INPUT');
        let maxLength = 3;
        forEachRow(1, rowCount, function(row) {
            forEachColumn(row, anchorColumn, anchorColumn+1, function(cell) {
                const c = cell.textContent.length;
                if (maxLength < c) {
                    maxLength = c;
                }
            });
        });
        inputBox.setAttribute('size', maxLength - 2);
        const anchor = getAnchor();
        oldCellValue = inputBox.value = anchor.textContent;
        anchor.textContent = '';
        anchor.appendChild(inputBox);
        inputBox.onkeydown = handleInputKey;
        inputBox.onblur = handleInputBlur;
        inputBox.setSelectionRange(0, inputBox.value.length);
        inputBox.focus();
    }
    function commitEdit() {
        if (inputBox) {
            const anchor = getAnchor();
            if (oldCellValue !== inputBox.value) {
                // make an undo action if we actually changed anything
                const vss = [[oldCellValue]];
                const thisRow = anchorRow;
                const thisColumn = anchorColumn;
                undoable(function() {
                    return putCellsAction(thisRow, thisRow + 1,
                            thisColumn, thisColumn + 1, vss);
                });
            }
            // Chrome blurs the input box when the textContent is set,
            // causing commitEdit() to be called again, so we must
            // make sure we do not cause another undo event.
            const newValue = inputBox.value;
            inputBox = null;
            // setting textContent deletes the INPUT element
            anchor.textContent = newValue;
        }
    }
    function handleInputBlur() {
        commitEdit();
        table.focus();
    }
    function getTbody() {
        const tbodies = table.getElementsByTagName('TBODY');
        if (tbodies.length < 1) {
            throw 'No tbodies in table!';
        }
        return tbodies[0];
    }
    function insertRows(r, count) {
        commitEdit();
        const tbody = getTbody();
        const insertFunction = r < rowCount?
            function(child) { tbody.insertBefore(child, getRow(r)); }
            : function(child) { tbody.appendChild(child); };
        for (var i = 0; i !== count; ++i) {
            const row = document.createElement('TR');
            const rowHeader = document.createElement('TH');
            rowHeader.textContent = r + i;
            row.appendChild(rowHeader);
            for (var j = 0; j != columnCount; ++j) {
                row.appendChild(document.createElement('TD'));
            }
            insertFunction(row);
        }
        rowCount += count;
        let selectionEndsMoved = 0;
        if (r <= anchorRow) {
            selectionEndsMoved += 1;
            anchorRow += count;
        }
        if (r <= selectionRow) {
            selectionEndsMoved += 1;
            selectionRow += count;
        }
        setCellMouseHandlers(r);
        if (selectionEndsMoved === 1) {
            forEachRow(r, r + count, markSelectedColumns);
        }
        return function() {
            return deleteRows(r, count);
        };
    }
    function deleteRows(r, count) {
        commitEdit();
        const values = getCells(r, r+count, 0, columnCount);
        const tbody = getTbody();
        for (i = 0; i !== count; ++i) {
            tbody.removeChild(tbody.children[r - 1]);
        }
        rowCount -= count;
        if (r < anchorRow) {
            if (r + count < anchorRow) {
                anchorRow -= count;
            } else {
                anchorRow = r;
            }
        }
        if (rowCount <= anchorRow) {
            anchorRow = rowCount - 1;
        }
        if (r < selectionRow) {
            if (r + count < selectionRow) {
                selectionRow -= count;
            } else {
                selectionRow = r;
            }
        }
        if (rowCount <= selectionRow) {
            selectionRow = rowCount - 1;
        }
        setCellMouseHandlers(r);
        return function() {
            const inverse = insertRows(r, count);
            putCells(r, r+count, 0, columnCount, values);
            return inverse;
        };
    }
    function markSelectedColumns(row) {
        forEachSelectedColumn(row, function(cell) {
            cell.classList.add('selected');
        });
    }
    function setSelection(aRow, aColumn, sRow, sColumn) {
        getAnchor().classList.remove('anchor');
        forEachSelectedRow(function(row) {
            forEachSelectedColumn(row, function(cell) {
                cell.classList.remove('selected');
            });
        });
        anchorRow = aRow;
        anchorColumn = aColumn;
        selectionRow = sRow;
        selectionColumn = sColumn;
        forEachSelectedRow(function(row) {
            markSelectedColumns(row);
        });
        getAnchor().classList.add('anchor');
    }
    function doGoToCell(r,c) {
        commitEdit();
        getAnchor().classList.remove('anchor');
        if (r < 0 || rowCount <= r
                || c < 0 || columnCount <= c) {
            return;
        }
        setSelection(r, c, r, c);
        getAnchor().classList.add('anchor');
        beginEdit();
    }
    function goToNextRow() {
        if (rowCount <= anchorRow + 1) {
            undoable(insertRows(rowCount, 1));
        }
        doGoToCell(anchorRow + 1, returnColumn);
    }
    function goToPreviousCell() {
        doGoToCell(anchorRow, anchorColumn - 1);
    }
    function goToNextCell() {
        if (anchorColumn + 1 < columnCount) {
            doGoToCell(anchorRow, anchorColumn + 1);
        } else {
            goToNextRow();
        }
    }
    function goToCell(r,c) {
        returnColumn = c;
        doGoToCell(r,c);
    }
    function deleteRowsOption(count) {
        const el = document.createElement('OPTION');
        el.setAttribute('option', 'delete');
        el.textContent = 'Delete Row';
        return el;
    }
    function addRowsBeforeOption(count) {
        const el = document.createElement('OPTION');
        el.setAttribute('option', 'add-before');
        el.textContent = 'Add Row Before';
        return el;
    }
    function addRowsAfterOption(count) {
        const el = document.createElement('OPTION');
        el.setAttribute('option', 'add-after');
        el.textContent = 'Add Row After';
        return el;
    }
    function rowHeaderMenu(ev, r) {
        let firstRow = r;
        if ((r < anchorRow && r < selectionRow)
                || anchorRow < r && selectionRow < r) {
            setSelection(r, 0, r, columnCount - 1);
        }
        contextMenu = document.createElement('SELECT');
        contextMenu.setAttribute('size', 3);
        const deleteOption = deleteRowsOption();
        deleteOption.onclick = function() {
            undoable(deleteRows(firstRow, 1));
            table.focus();
        }
        contextMenu.appendChild(deleteOption);
        const addBeforeOption = addRowsBeforeOption();
        addBeforeOption.onclick = function() {
            undoable(insertRows(firstRow, 1));
            table.focus();
        }
        contextMenu.appendChild(addBeforeOption);
        const addAfterOption = addRowsAfterOption();
        addAfterOption.onclick = function() {
            undoable(insertRows(firstRow + 1, 1));
            table.focus();
        }
        contextMenu.appendChild(addAfterOption);
        const mousePosition = getMouseCoordinates(ev);
        contextMenu.style.position = 'fixed';
        contextMenu.style.left = mousePosition.x + 'px';
        contextMenu.style.top = mousePosition.y + 'px';
        contextMenu.tabIndex = -1;
        contextMenu.zIndex = 10;
        contextMenu.onblur = removeContextMenu;
        contextMenu.contentEditable = false;
        table.appendChild(contextMenu);
        return contextMenu;
    }
    function forEachRow(rowStart, rowEnd, callback) {
        const rows = table.getElementsByTagName('TR');
        const rEnd = (rows.length < rowEnd? rows.length : rowEnd) - rowStart;
        for (var i = 0; i !== rEnd; ++i) {
            callback(rows[rowStart + i], i, rowStart + i);
        }
    }
    function forEachColumn(row, columnStart, columnEnd, callback) {
        const cs = row.getElementsByTagName('TD');
        let cEnd = (cs.length < columnEnd? cs.length : columnEnd) - columnStart;
        for (var i = 0; i !== cEnd; ++i)  {
            callback(cs[columnStart + i], i, columnStart + i);
        }
    }
    function forEachSelectedRow(callback) {
        forEachRow(Math.min(anchorRow, selectionRow),
                Math.max(anchorRow, selectionRow) + 1, callback);
    }
    function forEachSelectedColumn(row, callback) {
        forEachColumn(row, Math.min(anchorColumn, selectionColumn),
                Math.max(anchorColumn, selectionColumn) + 1, callback);
    }
    function setCellMouseHandlers(firstRow) {
        forEachRow(firstRow, rowCount, function(row, i, thisRow) {
            rowHeaders = row.getElementsByTagName('TH');
            if (0 < rowHeaders.length) {
                const rh = rowHeaders[0];
                rh.textContent = thisRow;
                rh.oncontextmenu = function(ev) {
                    ev = getEvent(ev);
                    const select = rowHeaderMenu(ev, thisRow);
                    select.focus();
                    return preventDefault(ev);
                }
                forEachColumn(row, 0, columnCount, function(cell, j, thisColumn) {
                    cell.onclick = function() {
                        goToCell(thisRow, thisColumn);
                    };
                    cell.onmouseenter = function(ev) {
                        ev = getEvent(ev);
                        // stretch selection over this cell
                        if (ev.buttons & 1) {
                            setSelection(anchorRow, anchorColumn, thisRow, thisColumn);
                            table.focus();
                            return preventDefault(ev);
                        }
                    };
                    cell.onmousedown = function(ev) {
                        ev = getEvent(ev);
                        // set anchor and selection to this cell
                        if (ev.button === 0) {
                            commitEdit();
                            setSelection(thisRow, thisColumn, thisRow, thisColumn);
                            table.focus();
                            return preventDefault(ev);
                        }
                    }
                });
            }
        });
    }
    function getCells(rowStart, rowEnd, columnStart, columnEnd) {
        let vss = [];
        forEachRow(rowStart, rowEnd, function(row) {
            let vs = [];
            forEachColumn(row, columnStart, columnEnd, function(cell) {
                vs.push(cell.textContent);
            });
            vss.push(vs);
        });
        return vss;
    }
    function putCells(rowStart, rowEnd, columnStart, columnEnd, values) {
        forEachRow(rowStart, rowEnd, function(row, i) {
            forEachColumn(row, columnStart, columnEnd, function(cell, j) {
                const vr = values[i];
                cell.textContent = typeof(vr) === 'undefined'? '' : vr[j];
            });
        });
    }
    function putCellsAction(rowStart, rowEnd, columnStart, columnEnd, values) {
        const oldValues = getCells(rowStart, rowEnd, columnStart, columnEnd);
        putCells(rowStart, rowEnd, columnStart, columnEnd, values);
        return function() { return putCellsAction(rowStart, rowEnd, columnStart, columnEnd, oldValues) };
    }
    function redo() {
        commitEdit();
        if (0 < redoStack.length) {
            const action = redoStack.pop();
            undoStack.push(action());
        }
    }
    function undo() {
        commitEdit();
        if (0 < undoStack.length) {
            const action = undoStack.pop();
            redoStack.push(action());
        }
    }
    function clearSelection() {
        const firstRow = Math.min(anchorRow, selectionRow);
        const lastRow = Math.max(anchorRow, selectionRow) + 1;
        const firstColumn = Math.min(anchorColumn, selectionColumn);
        const lastColumn = Math.max(anchorColumn, selectionColumn) + 1;
        let row = [];
        for (let i = firstColumn; i !== lastColumn; ++i) {
            row.push('');
        }
        let empties = [];
        for (let j = firstRow; j !== lastRow; ++j) {
            empties.push(row);
        }
        undoable(putCellsAction(firstRow, lastRow, firstColumn, lastColumn, empties));
    }
    function putClipboard(text) {
        const buffer = table.getElementsByClassName('data-entry-grid-copy-paste-buffer')[0];
        buffer.value = text;
        buffer.select();
        buffer.setSelectionRange(0, buffer.value.length);
        document.execCommand('copy');
    }
    function copySelection() {
        let texts = [];
        forEachSelectedRow(function(row) {
            let rowTexts = [];
            forEachSelectedColumn(row, function(cell) {
                const inputs = cell.getElementsByTagName('INPUT');
                if (0 < inputs.length) {
                    rowTexts.push(inputs[0].value)
                } else {
                    rowTexts.push(cell.textContent);
                }
            });
            texts.push(rowTexts.join('\t'));
        });
        return texts.join('\n');
    }
    function paste(clip) {
        if (clip.length === 0) {
            return;
        }
        let values = [];
        let maxRowLength = 0;
        const lines = clip.split('\n');
        if (lines[lines.length - 1].length === 0) {
            lines.pop();
        }
        for (let i = 0; i !== lines.length; ++i) {
            const row = lines[i].split('\t');
            values.push(row);
            if (maxRowLength < row.length) {
                maxRowLength = row.length;
            }
        }
        const firstRow = Math.min(anchorRow, selectionRow);
        let lastRow = Math.max(anchorRow, selectionRow) + 1;
        const firstColumn = Math.min(anchorColumn, selectionColumn);
        let lastColumn = Math.max(anchorColumn, selectionColumn) + 1;
        if (lastColumn < firstColumn + maxRowLength) {
            lastColumn = firstColumn + maxRowLength;
        }
        if (lastRow < firstRow + values.length) {
            lastRow = firstRow + values.length;
            if (rowCount < lastRow) {
                undoable(insertRows(rowCount, lastRow - rowCount));
            }
        }
        // fill out extra columns if more are wanted
        for (let c = firstColumn + maxRowLength; c < lastColumn; ++c) {
            const source = c % maxRowLength;
            for (let r = 0; r != values.length; ++r) {
                values[r][c - firstColumn] = values[r][source];
            }
        }
        // fill out extra rows if more are wanted
        const valueRowCount = values.length;
        const wantedRowCount = lastRow - firstRow;
        for (let r = valueRowCount; r < wantedRowCount; ++r) {
            values[r] = values[r % valueRowCount];
        }
        undoable(putCellsAction(firstRow, lastRow, firstColumn, lastColumn, values));
    }
    function tableKeyPressHandler(ev) {
        ev = getEvent(ev);
        if (contextMenu) {
            return;
        }
        if (!inputBox) {
            beginEdit();
            const cc = ev.charCode || ev.keyCode; // IE8 polyfill
            inputBox.value = String.fromCharCode(cc);
            return preventDefault(ev);
        }
    }
    function tableCutHandler(ev) {
        ev = getEvent(ev);
        const text = copySelection();
        ev.clipboardData.setData('text/plain', text);
        clearSelection();
        table.focus(); // seems necessary on Firefox
        return preventDefault(ev);
    }
    function tableCopyHandler(ev) {
        ev = getEvent(ev);
        const text = copySelection();
        ev.clipboardData.setData('text/plain', text);
        return preventDefault(ev);
    }
    function tablePasteHandler(ev) {
        ev = getEvent(ev);
        if (0 <= ev.clipboardData.types.indexOf('text/plain')) {
            try {
                paste(ev.clipboardData.getData('text/plain'));
            } catch (err) {
                // catch and discard the error because otherwise
                // the data will get pasted into the table!
                console.log(err);
            }
        }
        table.focus(); // seems necessary on Firefox
        return preventDefault(ev);
    }
    function tableKeyDownHandler(ev) {
        ev = getEvent(ev);
        if (contextMenu) {
            if (ev.key === 'Escape') {
                table.focus();
            }
            // Select context menu option if enter or space pressed.
            // Surely there must be a better way to do this?
            if (ev.key === 'Enter' || ev.key === ' ') {
                const index = contextMenu.selectedIndex;
                if (0 <= index) {
                    const options = contextMenu.getElementsByTagName('option');
                    options[index].onclick();
                    return preventDefault(ev);
                }
            }
            return;
        }
        // meta key so that Apple users can press meta-Z for undo.
        if ((ev.ctrlKey || ev.metaKey) && !ev.altKey) {
            if (ev.keyCode === 90) {
                if (ev.shiftKey) {
                    redo();
                } else {
                    undo();
                }
                return preventDefault(ev);
            }
        }
        if (ev.key === 'Delete' || ev.key === 'Backspace') {
            clearSelection();
            return preventDefault(ev);
        }
        if (moveSelection(ev) === false) {
            return preventDefault(ev);
        }
        if (moveAnchor(ev) === false) {
            return preventDefault(ev);
        }
    }
    function moveAnchor(ev) {
        if (ev.shiftKey || ev.altKey || ev.ctrlKey || ev.metaKey) {
            return;
        }
        if (ev.key === 'ArrowUp' && 1 < anchorRow) {
            commitEdit();
            setSelection(anchorRow - 1, anchorColumn, anchorRow - 1, anchorColumn);
            beginEdit();
            return false;
        }
        if (ev.key === 'ArrowDown' && anchorRow + 1 < rowCount) {
            commitEdit();
            setSelection(anchorRow + 1, anchorColumn, anchorRow + 1, anchorColumn);
            beginEdit();
            return false;
        }
        const inputNotSelected = inputBox &&
                inputBox.selectionStart === inputBox.selectionEnd;
        const inputAtStart = inputNotSelected && inputBox.selectionStart === 0;
        const inputAtEnd = inputNotSelected && inputBox.selectionStart === inputBox.value.length;
        if (ev.key === 'ArrowLeft' && 0 < anchorColumn
                && (!inputBox || inputAtStart)) {
            commitEdit();
            setSelection(anchorRow, anchorColumn - 1, anchorRow, anchorColumn - 1);
            returnColumn = anchorColumn;
            beginEdit();
            return false;
        }
        if (ev.key === 'ArrowRight' && anchorColumn + 1 < columnCount
                && (!inputBox || inputAtEnd)) {
            commitEdit();
            setSelection(anchorRow, anchorColumn + 1, anchorRow, anchorColumn + 1);
            returnColumn = anchorColumn;
            beginEdit();
            return false;
        }
    }
    function moveSelection(ev) {
        if (!ev.shiftKey || ev.altKey || ev.ctrlKey || ev.metaKey) {
            return;
        }
        if (ev.key === 'ArrowUp' && 1 < selectionRow) {
            setSelection(anchorRow, anchorColumn, selectionRow - 1, selectionColumn);
            return false;
        }
        if (ev.key === 'ArrowDown' && selectionRow + 1 < rowCount) {
            setSelection(anchorRow, anchorColumn, selectionRow + 1, selectionColumn);
            return false;
        }
        if (ev.key === 'ArrowLeft' && 0 < selectionColumn) {
            setSelection(anchorRow, anchorColumn, selectionRow, selectionColumn - 1);
            return false;
        }
        if (ev.key === 'ArrowRight' && selectionColumn + 1 < columnCount) {
            setSelection(anchorRow, anchorColumn, selectionRow, selectionColumn + 1);
            return false;
        }
    }
    setCellMouseHandlers(1);
    table.onkeydown = tableKeyDownHandler;
    table.onkeypress = tableKeyPressHandler;
    table.contentEditable = true;
    table.oncut = tableCutHandler;
    table.oncopy = tableCopyHandler;
    table.onpaste = tablePasteHandler;
    table.onmousemove = function (ev) {
        ev = getEvent(ev);
        // prevent default drag-select
        if (ev.buttons & 1) {
            return preventDefault(ev);
        }
    };
    table.onmousedown = function (ev) {
        ev = getEvent(ev);
        // prevent default drag-select
        if (ev.button === 0) {
            return preventDefault(ev);
        }
    };
    table.tabIndex = 0;
    const copyPasteBuffer = document.createElement('TEXTAREA');
    copyPasteBuffer.classList.add('data-entry-grid-copy-paste-buffer');
    copyPasteBuffer.style.position = 'fixed';
    copyPasteBuffer.style.top = '0';
    copyPasteBuffer.style.right = '100%';
    copyPasteBuffer.style.zIndex = '-1';
    copyPasteBuffer.style.opacity = '0';
    table.appendChild(copyPasteBuffer);
    table.focus();
    return {
        goToCell: goToCell,
        undo: undo,
        redo: redo
    };
};
var dataEntryGrid;
</script>
</head>
<body onload="dataEntryGrid = createDataEntryGrid('input',3,3)">
    <table id='input' class='data-entry-grid'>
        <thead>
            <tr>
                <th></th>
                <th>One</th>
                <th>Two</th>
                <th>Three</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <th>1</th>
                <td class='anchor'>1</td>
                <td>2</td>
                <td>3</td>
            </tr>
            <tr>
                <th>2</th>
                <td>10.1</td>
                <td>20.2</td>
                <td>30.3</td>
            </tr>
        </tbody>
    </table>
</body>
</html>
