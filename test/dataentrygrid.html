<html>
<head>
<title>Home-made grid test</title>
<meta charset='UTF-8'/>
<style>
table.data-entry-grid {
    border: 1px solid black;
    background-color: white;
    border-collapse: collapse;
    padding-left: 5px;
    padding-right: 5px;
    padding-top: 0px;
    padding-bottom: 0px;
}
table.data-entry-grid th, table.data-entry-grid td {
    border: 1px solid black;
    background-color: white;
    border-collapse: collapse;
    padding-left: 5px;
    padding-right: 5px;
    padding-top: 0px;
    padding-bottom: 0px;
}
table.data-entry-grid input {
    border: 0;
}
table.data-entry-grid td.selected {
    border: 1px solid blue;
    background-color: lightskyblue;
    border-collapse: collapse;
    padding-left: 5px;
    padding-right: 5px;
    padding-top: 0px;
    padding-bottom: 0px;
}
table.data-entry-grid td.anchor {
    border: 3px solid blue;
    background-color: lightskyblue;
    border-collapse: collapse;
    padding-left: 5px;
    padding-right: 5px;
    padding-top: 0px;
    padding-bottom: 0px;
}
</style>
<script>
function createDataEntryGrid(containerId, rows, columns) {
    var rowCount = rows;
    var columnCount = columns;
    var anchorRow = 1;
    var anchorColumn = 0;
    var selectionRow = 1;
    var selectionColumn = 0;
    var returnColumn = 0;
    var undoStack = [];
    var redoStack = [];
    var inputBox = null;
    var contextMenu = null;
    var localizedText = {
        deleteRow: 'Delete row',
        addRowBefore: 'Add row before',
        addRowAfter: 'Add row after'
    };
    function noop() { return null; }
    var commitEdit = noop;
    var table = document.getElementById(containerId); // while we aren't creating our own table
    // undoable(myAction()) pushes the inverse action onto the undo stack
    function undoable(action) {
        if (action !== null) {
            undoStack.push(action);
            redoStack = [];
        }
    }
    function getRow(r) {
        return table.getElementsByTagName('TR')[r];
    }
    function getCell(r,c) {
        return getRow(r).getElementsByTagName('TD')[c];
    }
    function getAnchor() {
        return getCell(anchorRow, anchorColumn);
    }
    function getColumnHeaders() {
        var thead = table.getElementsByTagName('THEAD');
        if (thead.length === 0) {
            return [];
        }
        var ths = thead[0].getElementsByTagName('TH');
        var headers = [];
        for (var i = 1; i !== ths.length; ++i) {
            headers.push(ths[i].textContent);
        }
        return headers;
    }
    // Create a DOM element containing a load of other
    // elements:
    // createElementArray('TR', 'TD', ['one, 'two', 'three'], function(e,x) {e.textContent = x;})
    // Can use an already-constructed element for container.
    // Can use the number of items instead of an array for items (and get 0, 1, 2...)
    // Can leave out adaptFn.
    function createElementArray(container, element, items, adaptFn) {
        if (typeof(container) === 'string') {
            container = document.createElement(container);
        }
        var size = items;
        var getItem = function(index) { return index; }
        if (typeof(items) === 'object') {
            getItem = function(index) { return items[index]; }
            size = items.length;
        }
        for (var i = 0; i != size; ++i) {
            var sub = document.createElement(element);
            if (adaptFn) {
                adaptFn(sub, getItem(i));
            }
            container.appendChild(sub);
        }
        return container;
    }
    function init(headers, newRowCount) {
        var thead = createElementArray('THEAD', 'TR', 1, function(tr) {
            createElementArray(tr, 'TH', 1);
            createElementArray(tr, 'TH', headers, function(e, x) {
                e.textContent = x;
            });
        });
        var tbody = createElementArray('TBODY', 'TR', newRowCount, function(tr, i) {
            createElementArray(tr, 'TH', 1);
            createElementArray(tr, 'TD', headers.length, function(td, j) {
                if (i == 0 && j == 0) {
                    td.setAttribute('class', 'anchor');
                }
            });
        });
        var oldTHeads = table.getElementsByTagName('THEAD');
        if (oldTHeads.length == 0) {
            table.appendChild(thead);
        } else {
            table.replaceChild(thead, oldTHeads[0]);
        }
        var oldTBodies = table.getElementsByTagName('TBODY');
        if (oldTBodies.length == 0) {
            table.appendChild(tbody);
        } else {
            table.replaceChild(tbody, oldTBodies[0]);
        }
        anchorRow = 1;
        selectionRow = 1;
        anchorColumn = 0;
        selectionColumn = 0;
        rowCount = newRowCount + 1;
        columnCount = headers.length;
        clearUndo();
        setCellMouseHandlers(1);
    }
    function removeContextMenu() {
        if (contextMenu) {
            table.removeChild(contextMenu);
            contextMenu = null;
        }
    }
    function getMouseCoordinates(ev) {
        // polyfill
        if (ev.pageX || ev.pageY) {
            return { x: ev.pageX, y: ev.pageY };
        }
        return {
            x: ev.clientX + document.body.scrollLeft + document.documentElement.scrollLeft,
            y: ev.clientY + document.body.scrollTop + document.documentElement.scrollTop
        }
    }
    function preventDefault(ev) {
        // Firefox polyfill
        if (ev.preventDefault) {
            ev.preventDefault();
        }
        // standard?
        if (ev.stopPropagation) {
            ev.stopPropagation();
        }
        // IE polyfill
        ev.cancelBubble = true;
        // IE7/8 polyfill
        return false;
    }
    function getEvent(ev) {
        // polyfill
        return ev? ev : window.event;
    }
    function handleInputKey(ev) {
        ev = getEvent(ev);
        if (ev.keyCode === 9) {
            if (ev.shiftKey) {
                goToPreviousCell();
            } else {
                goToNextCell();
            }
            return preventDefault(ev);
        } else if (ev.keyCode === 13) {
            goToNextRow();
            return preventDefault(ev);
        }
        return true;
    }
    function beginEdit() {
        const box = document.createElement('INPUT');
        const r = anchorRow;
        const c = anchorColumn;
        let maxLength = 3;
        forEachRow(1, rowCount, function(row) {
            forEachColumn(row, c, c+1, function(cell) {
                const len = cell.textContent.length;
                if (maxLength < len) {
                    maxLength = len;
                }
            });
        });
        box.setAttribute('size', maxLength - 2);
        const cell = getCell(r, c);
        const text = cell.textContent;
        box.value = text;
        cell.textContent = '';
        cell.appendChild(box);
        commitEdit = function() { return doCommitEdit(r, c, box, text); }
        box.onkeydown = handleInputKey;
        box.onblur = function() {
            undoable(doCommitEdit(r, c, box, text));
            table.focus();
        }
        box.setSelectionRange(0, box.value.length);
        box.focus();
        inputBox = box;
    }
    function doCommitEdit(row, column, box, oldValue) {
        inputBox = null;
        commitEdit = noop;
        var newValue = box.value;
        if (box.parentNode === null) {
            return null;
        }
        putCells(row, row+1, column, column+1, [[newValue]]);
        if (oldValue === newValue) {
            return null;
        }
        return function() { return putCellsAction(row, row+1, column, column+1, [[oldValue]]) };
    }
    function getTbody() {
        const tbodies = table.getElementsByTagName('TBODY');
        if (tbodies.length < 1) {
            throw 'No tbodies in table!';
        }
        return tbodies[0];
    }
    function insertRows(r, count) {
        undoable(commitEdit());
        const tbody = getTbody();
        const insertFunction = r < rowCount?
            function(child) { tbody.insertBefore(child, getRow(r)); }
            : function(child) { tbody.appendChild(child); };
        for (var i = 0; i !== count; ++i) {
            const row = document.createElement('TR');
            const rowHeader = document.createElement('TH');
            rowHeader.textContent = r + i;
            row.appendChild(rowHeader);
            for (var j = 0; j != columnCount; ++j) {
                row.appendChild(document.createElement('TD'));
            }
            insertFunction(row);
        }
        rowCount += count;
        let selectionEndsMoved = 0;
        if (r <= anchorRow) {
            selectionEndsMoved += 1;
            anchorRow += count;
        }
        if (r <= selectionRow) {
            selectionEndsMoved += 1;
            selectionRow += count;
        }
        setCellMouseHandlers(r);
        if (selectionEndsMoved === 1) {
            forEachRow(r, r + count, markSelectedColumns);
        }
        return function() {
            return deleteRows(r, count);
        };
    }
    function deleteRows(r, count) {
        undoable(commitEdit());
        const values = getCells(r, r+count, 0, columnCount);
        const tbody = getTbody();
        for (i = 0; i !== count; ++i) {
            tbody.removeChild(tbody.children[r - 1]);
        }
        rowCount -= count;
        if (r < anchorRow) {
            if (r + count < anchorRow) {
                anchorRow -= count;
            } else {
                anchorRow = r;
            }
        }
        if (rowCount <= anchorRow) {
            anchorRow = rowCount - 1;
        }
        if (r < selectionRow) {
            if (r + count < selectionRow) {
                selectionRow -= count;
            } else {
                selectionRow = r;
            }
        }
        if (rowCount <= selectionRow) {
            selectionRow = rowCount - 1;
        }
        setCellMouseHandlers(r);
        return function() {
            const inverse = insertRows(r, count);
            putCells(r, r+count, 0, columnCount, values);
            return inverse;
        };
    }
    function markSelectedColumns(row) {
        forEachSelectedColumn(row, function(cell) {
            cell.classList.add('selected');
        });
    }
    function setSelection(aRow, aColumn, sRow, sColumn) {
        getAnchor().classList.remove('anchor');
        forEachSelectedRow(function(row) {
            forEachSelectedColumn(row, function(cell) {
                cell.classList.remove('selected');
            });
        });
        anchorRow = aRow;
        anchorColumn = aColumn;
        selectionRow = sRow;
        selectionColumn = sColumn;
        forEachSelectedRow(function(row) {
            markSelectedColumns(row);
        });
        getAnchor().classList.add('anchor');
    }
    function doGoToCell(r,c) {
        undoable(commitEdit());
        getAnchor().classList.remove('anchor');
        if (r < 0 || rowCount <= r
                || c < 0 || columnCount <= c) {
            return;
        }
        setSelection(r, c, r, c);
        getAnchor().classList.add('anchor');
        beginEdit();
    }
    function goToNextRow() {
        if (rowCount <= anchorRow + 1) {
            undoable(insertRows(rowCount, 1));
        }
        doGoToCell(anchorRow + 1, returnColumn);
    }
    function goToPreviousCell() {
        doGoToCell(anchorRow, anchorColumn - 1);
    }
    function goToNextCell() {
        if (anchorColumn + 1 < columnCount) {
            doGoToCell(anchorRow, anchorColumn + 1);
        } else {
            goToNextRow();
        }
    }
    function goToCell(r,c) {
        returnColumn = c;
        doGoToCell(r,c);
    }
    function deleteRowsOption(count) {
        const el = document.createElement('OPTION');
        el.setAttribute('value', 'delete');
        el.textContent = localizedText.deleteRow;
        return el;
    }
    function addRowsBeforeOption(count) {
        const el = document.createElement('OPTION');
        el.setAttribute('value', 'add-before');
        el.textContent = localizedText.addRowBefore;
        return el;
    }
    function addRowsAfterOption(count) {
        const el = document.createElement('OPTION');
        el.setAttribute('value', 'add-after');
        el.textContent = localizedText.addRowAfter;
        return el;
    }
    function rowHeaderMenu(ev, r) {
        let firstRow = r;
        let count = 1;
        if ((r < anchorRow && r < selectionRow)
                || anchorRow < r && selectionRow < r) {
            setSelection(r, 0, r, columnCount - 1);
        } else {
            if (anchorRow < selectionRow) {
                firstRow = anchorRow;
                count = selectionRow - anchorRow + 1;
            } else {
                firstRow = selectionRow;
                count = anchorRow - selectionRow + 1;
            }
        }
        contextMenu = document.createElement('SELECT');
        const id = table.getAttribute('id').concat('-row-menu');
        contextMenu.setAttribute('id', id);
        contextMenu.setAttribute('size', 3);
        const deleteOption = deleteRowsOption();
        deleteOption.onclick = function() {
            undoable(deleteRows(firstRow, count));
            table.focus();
        }
        contextMenu.appendChild(deleteOption);
        const addBeforeOption = addRowsBeforeOption();
        addBeforeOption.onclick = function() {
            undoable(insertRows(firstRow, count));
            table.focus();
        }
        contextMenu.appendChild(addBeforeOption);
        const addAfterOption = addRowsAfterOption();
        addAfterOption.onclick = function() {
            undoable(insertRows(firstRow + count, count));
            table.focus();
        }
        contextMenu.appendChild(addAfterOption);
        const mousePosition = getMouseCoordinates(ev);
        contextMenu.style.position = 'fixed';
        contextMenu.style.left = mousePosition.x + 'px';
        contextMenu.style.top = mousePosition.y + 'px';
        contextMenu.tabIndex = -1;
        contextMenu.zIndex = 10;
        contextMenu.onblur = removeContextMenu;
        contextMenu.contentEditable = false;
        table.appendChild(contextMenu);
        return contextMenu;
    }
    function forEachRow(rowStart, rowEnd, callback) {
        const rows = table.getElementsByTagName('TR');
        const rEnd = (rows.length < rowEnd? rows.length : rowEnd) - rowStart;
        for (var i = 0; i < rEnd; ++i) {
            callback(rows[rowStart + i], i, rowStart + i);
        }
    }
    function forEachColumn(row, columnStart, columnEnd, callback) {
        const cs = row.getElementsByTagName('TD');
        let cEnd = (cs.length < columnEnd? cs.length : columnEnd) - columnStart;
        for (var i = 0; i < cEnd; ++i)  {
            callback(cs[columnStart + i], i, columnStart + i);
        }
    }
    function forEachSelectedRow(callback) {
        forEachRow(Math.min(anchorRow, selectionRow),
                Math.max(anchorRow, selectionRow) + 1, callback);
    }
    function forEachSelectedColumn(row, callback) {
        forEachColumn(row, Math.min(anchorColumn, selectionColumn),
                Math.max(anchorColumn, selectionColumn) + 1, callback);
    }
    function setCellMouseHandlers(firstRow) {
        forEachRow(firstRow, rowCount, function(row, i, thisRow) {
            rowHeaders = row.getElementsByTagName('TH');
            if (0 < rowHeaders.length) {
                const rh = rowHeaders[0];
                rh.textContent = thisRow;
                rh.oncontextmenu = function(ev) {
                    ev = getEvent(ev);
                    const select = rowHeaderMenu(ev, thisRow);
                    select.focus();
                    return preventDefault(ev);
                }
                forEachColumn(row, 0, columnCount, function(cell, j, thisColumn) {
                    cell.onclick = function() {
                        goToCell(thisRow, thisColumn);
                    };
                    cell.onmouseenter = function(ev) {
                        ev = getEvent(ev);
                        // stretch selection over this cell
                        if (ev.buttons & 1) {
                            setSelection(anchorRow, anchorColumn, thisRow, thisColumn);
                            table.focus();
                            return preventDefault(ev);
                        }
                    };
                    cell.onmousedown = function(ev) {
                        ev = getEvent(ev);
                        // set anchor and selection to this cell
                        if (ev.button === 0) {
                            undoable(commitEdit());
                            setSelection(thisRow, thisColumn, thisRow, thisColumn);
                            table.focus();
                            return preventDefault(ev);
                        }
                    }
                });
            }
        });
    }
    function getCells(rowStart, rowEnd, columnStart, columnEnd) {
        let vss = [];
        forEachRow(rowStart, rowEnd, function(row) {
            let vs = [];
            forEachColumn(row, columnStart, columnEnd, function(cell) {
                const inputs = cell.getElementsByTagName('INPUT');
                if (0 < inputs.length) {
                    vs.push(inputs[0].value)
                } else {
                    vs.push(cell.textContent);
                }
            });
            vss.push(vs);
        });
        return vss;
    }
    function putCells(rowStart, rowEnd, columnStart, columnEnd, values) {
        forEachRow(rowStart, rowEnd, function(row, i) {
            var vr = values[i];
            forEachColumn(row, columnStart, columnEnd, function(cell, j) {
                cell.textContent = typeof(vr) === 'undefined'? '' : vr[j];
            });
        });
    }
    // an 'action' is a function that returns its inverse (which is also an action
    // and so returns a function that is the equivalent of the original action)
    function putCellsAction(rowStart, rowEnd, columnStart, columnEnd, values) {
        const oldValues = getCells(rowStart, rowEnd, columnStart, columnEnd);
        putCells(rowStart, rowEnd, columnStart, columnEnd, values);
        return function() { return putCellsAction(rowStart, rowEnd, columnStart, columnEnd, oldValues) };
    }
    function redo() {
        commitEdit();
        if (0 < redoStack.length) {
            const action = redoStack.pop()();
            if (action !== null) {
                undoStack.push(action);
            }
        }
        table.focus();
    }
    function undo() {
        undoable(commitEdit());
        if (0 < undoStack.length) {
            const action = undoStack.pop()();
            if (action !== null) {
                redoStack.push(action);
            }
        }
        table.focus();
    }
    function clearUndo() {
        redoStack = [];
        undoStack = [];
    }
    function clearSelection() {
        const firstRow = Math.min(anchorRow, selectionRow);
        const lastRow = Math.max(anchorRow, selectionRow) + 1;
        const firstColumn = Math.min(anchorColumn, selectionColumn);
        const lastColumn = Math.max(anchorColumn, selectionColumn) + 1;
        let row = [];
        for (let i = firstColumn; i !== lastColumn; ++i) {
            row.push('');
        }
        let empties = [];
        for (let j = firstRow; j !== lastRow; ++j) {
            empties.push(row);
        }
        undoable(putCellsAction(firstRow, lastRow, firstColumn, lastColumn, empties));
    }
    function putClipboard(text) {
        const buffer = table.getElementsByClassName('data-entry-grid-copy-paste-buffer')[0];
        buffer.value = text;
        buffer.select();
        buffer.setSelectionRange(0, buffer.value.length);
        document.execCommand('copy');
    }
    function copySelection() {
        let texts = [];
        forEachSelectedRow(function(row) {
            let rowTexts = [];
            forEachSelectedColumn(row, function(cell) {
                const inputs = cell.getElementsByTagName('INPUT');
                if (0 < inputs.length) {
                    rowTexts.push(inputs[0].value)
                } else {
                    rowTexts.push(cell.textContent);
                }
            });
            texts.push(rowTexts.join('\t'));
        });
        return texts.join('\n');
    }
    function paste(clip) {
        if (clip.length === 0) {
            return;
        }
        let values = [];
        let maxRowLength = 0;
        const lines = clip.split('\n');
        if (lines[lines.length - 1].length === 0) {
            lines.pop();
        }
        for (let i = 0; i !== lines.length; ++i) {
            const row = lines[i].split('\t');
            values.push(row);
            if (maxRowLength < row.length) {
                maxRowLength = row.length;
            }
        }
        const firstRow = Math.min(anchorRow, selectionRow);
        let lastRow = Math.max(anchorRow, selectionRow) + 1;
        const firstColumn = Math.min(anchorColumn, selectionColumn);
        let lastColumn = Math.max(anchorColumn, selectionColumn) + 1;
        if (lastColumn < firstColumn + maxRowLength) {
            lastColumn = firstColumn + maxRowLength;
        }
        if (lastRow < firstRow + values.length) {
            lastRow = firstRow + values.length;
            if (rowCount < lastRow) {
                undoable(insertRows(rowCount, lastRow - rowCount));
            }
        }
        // fill out extra columns if more are wanted
        for (let c = firstColumn + maxRowLength; c < lastColumn; ++c) {
            const source = c % maxRowLength;
            for (let r = 0; r != values.length; ++r) {
                values[r][c - firstColumn] = values[r][source];
            }
        }
        // fill out extra rows if more are wanted
        const valueRowCount = values.length;
        const wantedRowCount = lastRow - firstRow;
        for (let r = valueRowCount; r < wantedRowCount; ++r) {
            values[r] = values[r % valueRowCount];
        }
        undoable(putCellsAction(firstRow, lastRow, firstColumn, lastColumn, values));
    }
    function tableKeyPressHandler(ev) {
        ev = getEvent(ev);
        if (contextMenu) {
            return;
        }
        if (!inputBox) {
            beginEdit();
            const cc = ev.charCode || ev.keyCode; // IE8 polyfill
            inputBox.value = String.fromCharCode(cc);
            return preventDefault(ev);
        }
    }
    function tableCutHandler(ev) {
        ev = getEvent(ev);
        const text = copySelection();
        ev.clipboardData.setData('text/plain', text);
        clearSelection();
        table.focus(); // seems necessary on Firefox
        return preventDefault(ev);
    }
    function tableCopyHandler(ev) {
        ev = getEvent(ev);
        const text = copySelection();
        ev.clipboardData.setData('text/plain', text);
        return preventDefault(ev);
    }
    function tablePasteHandler(ev) {
        ev = getEvent(ev);
        if (0 <= ev.clipboardData.types.indexOf('text/plain')) {
            try {
                paste(ev.clipboardData.getData('text/plain'));
            } catch (err) {
                // catch and discard the error because otherwise
                // the data will get pasted into the table!
                console.log(err);
            }
        }
        table.focus(); // seems necessary on Firefox
        return preventDefault(ev);
    }
    function tableKeyDownHandler(ev) {
        ev = getEvent(ev);
        if (contextMenu) {
            if (ev.key === 'Escape') {
                table.focus();
            }
            // Select context menu option if enter or space pressed.
            // Surely there must be a better way to do this?
            if (ev.key === 'Enter' || ev.key === ' ') {
                const index = contextMenu.selectedIndex;
                if (0 <= index) {
                    const options = contextMenu.getElementsByTagName('option');
                    options[index].onclick();
                    return preventDefault(ev);
                }
            }
            return;
        }
        // meta key so that Apple users can press meta-Z for undo.
        if ((ev.ctrlKey || ev.metaKey) && !ev.altKey) {
            if (ev.keyCode === 90) {
                if (ev.shiftKey) {
                    redo();
                } else {
                    undo();
                }
                return preventDefault(ev);
            }
        }
        if (ev.key === 'Delete' || ev.key === 'Backspace') {
            clearSelection();
            return preventDefault(ev);
        }
        if (moveSelection(ev) === false) {
            return preventDefault(ev);
        }
        if (moveAnchor(ev) === false) {
            return preventDefault(ev);
        }
    }
    function moveAnchor(ev) {
        if (ev.shiftKey || ev.altKey || ev.ctrlKey || ev.metaKey) {
            return;
        }
        if (ev.key === 'ArrowUp' && 1 < anchorRow) {
            undoable(commitEdit());
            setSelection(anchorRow - 1, anchorColumn, anchorRow - 1, anchorColumn);
            beginEdit();
            return false;
        }
        if (ev.key === 'ArrowDown' && anchorRow + 1 < rowCount) {
            undoable(commitEdit());
            setSelection(anchorRow + 1, anchorColumn, anchorRow + 1, anchorColumn);
            beginEdit();
            return false;
        }
        const inputNotSelected = inputBox &&
                inputBox.selectionStart === inputBox.selectionEnd;
        const inputAtStart = inputNotSelected && inputBox.selectionStart === 0;
        const inputAtEnd = inputNotSelected && inputBox.selectionStart === inputBox.value.length;
        if (ev.key === 'ArrowLeft' && 0 < anchorColumn
                && (!inputBox || inputAtStart)) {
            undoable(commitEdit());
            setSelection(anchorRow, anchorColumn - 1, anchorRow, anchorColumn - 1);
            returnColumn = anchorColumn;
            beginEdit();
            return false;
        }
        if (ev.key === 'ArrowRight' && anchorColumn + 1 < columnCount
                && (!inputBox || inputAtEnd)) {
            undoable(commitEdit());
            setSelection(anchorRow, anchorColumn + 1, anchorRow, anchorColumn + 1);
            returnColumn = anchorColumn;
            beginEdit();
            return false;
        }
    }
    function moveSelection(ev) {
        if (!ev.shiftKey || ev.altKey || ev.ctrlKey || ev.metaKey) {
            return;
        }
        if (ev.key === 'ArrowUp' && 1 < selectionRow) {
            setSelection(anchorRow, anchorColumn, selectionRow - 1, selectionColumn);
            return false;
        }
        if (ev.key === 'ArrowDown' && selectionRow + 1 < rowCount) {
            setSelection(anchorRow, anchorColumn, selectionRow + 1, selectionColumn);
            return false;
        }
        if (ev.key === 'ArrowLeft' && 0 < selectionColumn) {
            setSelection(anchorRow, anchorColumn, selectionRow, selectionColumn - 1);
            return false;
        }
        if (ev.key === 'ArrowRight' && selectionColumn + 1 < columnCount) {
            setSelection(anchorRow, anchorColumn, selectionRow, selectionColumn + 1);
            return false;
        }
    }
    setCellMouseHandlers(1);
    table.onkeydown = tableKeyDownHandler;
    table.onkeypress = tableKeyPressHandler;
    table.contentEditable = true;
    table.oncut = tableCutHandler;
    table.oncopy = tableCopyHandler;
    table.onpaste = tablePasteHandler;
    table.onmousemove = function (ev) {
        ev = getEvent(ev);
        // prevent default drag-select
        if (ev.buttons & 1) {
            return preventDefault(ev);
        }
    };
    table.onmousedown = function (ev) {
        ev = getEvent(ev);
        // prevent default drag-select
        if (ev.button === 0) {
            return preventDefault(ev);
        }
    };
    table.tabIndex = 0;
    const copyPasteBuffer = document.createElement('TEXTAREA');
    copyPasteBuffer.classList.add('data-entry-grid-copy-paste-buffer');
    copyPasteBuffer.style.position = 'fixed';
    copyPasteBuffer.style.top = '0';
    copyPasteBuffer.style.right = '100%';
    copyPasteBuffer.style.zIndex = '-1';
    copyPasteBuffer.style.opacity = '0';
    table.appendChild(copyPasteBuffer);
    table.focus();
    return {
        init: init,
        setText: function(newText) {
            for (const k in localizedText) {
                if (k in newText) {
                    localizedText[k] = newText[k];
                }
            }
        },
        getSelection: function() { return {
            anchorRow: anchorRow,
            anchorColumn: anchorColumn,
            selectionRow: selectionRow,
            selectionColumn: selectionColumn
        };},
        rowCount: function() { return rowCount },
        columnCount: function() { return columnCount },
        getColumnHeaders: getColumnHeaders,
        goToCell: goToCell,
        getCells: getCells,
        putCells: function(startRow, endRow, startColumn, endColumn, values) {
            undoable(putCellsAction(startRow, endRow, startColumn, endColumn, values));
        },
        clearUndo: clearUndo,
        undo: undo,
        redo: redo
    };
};
</script>
</head>
<body onload="window.dataEntryGrid = createDataEntryGrid('input',3,3)">
    <table id='input' class='data-entry-grid'>
        <thead>
            <tr>
                <th></th>
                <th>One</th>
                <th>Two</th>
                <th>Three</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <th>1</th>
                <td class='anchor'>1</td>
                <td>2</td>
                <td>3</td>
            </tr>
            <tr>
                <th>2</th>
                <td>10.1</td>
                <td>20.2</td>
                <td>30.3</td>
            </tr>
        </tbody>
    </table>
</body>
</html>
